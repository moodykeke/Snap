<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ç”»ç¬”ç³»ç»ŸåŸå‹ï¼ˆPaper.jsï¼‰</title>
  <style>
    :root {
      --bg:#f6f7f9; --panel:#ffffff; --ink:#222; --ink-weak:#6b7280; --border:#e5e7eb; --accent:#6f61ef; --accent-ink:#fff;
    }
    body { margin: 0; font-family: system-ui, Arial, sans-serif; background: var(--bg); color: var(--ink); }
    /* ä¸»å¸ƒå±€ï¼šå·¦ä¾§å·¥å…· + ç”»å¸ƒ + å³ä¾§æ ‡ç­¾é¢æ¿ + åº•éƒ¨çŠ¶æ€æ  */
    #canvas-wrap { position: relative; height: 100vh; background: var(--panel); display: grid; grid-template-columns: 68px 1fr 340px; grid-template-rows: 1fr 26px; grid-template-areas: 'tools canvas right' 'status status status'; }
    /* å·¦ä¾§å·¥å…·æ  */
    #left-tools { grid-area: tools; border-right: 1px solid var(--border); background: var(--panel); display: grid; grid-auto-rows: 40px; place-items:center; padding-top: 8px; }
    #left-tools button { width: 32px; height: 32px; border-radius: 6px; border: 1px solid var(--border); background: var(--panel); cursor: pointer; font-size: 16px; color: var(--ink); }
    #left-tools button.active { outline: 2px solid var(--accent); }
    /* ç”»å¸ƒåŒº */
    #canvas-pane { grid-area: canvas; position: relative; background: repeating-conic-gradient(#eee 0% 25%, #fff 0% 50%) 50%/24px 24px; }
    /* è®©ç”»å¸ƒå°ºå¯¸å¯ç²¾ç¡®æ§åˆ¶ä¸ºèˆå°å°ºå¯¸ï¼ˆå»æ‰ inset:0 ä»¥å¯ç”¨ JS è®¾ç½®å®½é«˜ï¼‰*/
    #paper-canvas { position: absolute; left: 0; top: 0; display: block; }
    #raster-canvas { position: absolute; left: 0; top: 0; display: block; pointer-events: none; }
    /* ç”»å¸ƒå®¹å™¨å…è®¸å†…å®¹å°ºå¯¸ä¸ç­‰äºå®¹å™¨æ—¶å±…å·¦å¯¹é½ï¼ˆåç»­å¯å±…ä¸­ï¼‰ */
    #canvas-pane { grid-area: canvas; position: relative; background: repeating-conic-gradient(#eee 0% 25%, #fff 0% 50%) 50%/24px 24px; overflow: auto; }
    /* å³ä¾§é¢æ¿ */
    #right-pane { grid-area: right; border-left: 1px solid var(--border); background: var(--panel); display: grid; grid-template-rows: 36px 1fr; }
    #tabbar { display: flex; border-bottom: 1px solid var(--border); }
    #tabbar button { height: 36px; flex: 1; border: 0; background: var(--panel); cursor: pointer; font-size: 12px; color: var(--ink); }
    #tabbar button.active { background: #f0f2ff; color: var(--ink); border-bottom: 2px solid var(--accent); }
    #panels { position: relative; overflow: auto; }
    .panel { display: none; padding: 8px; }
    .panel.active { display: block; }
    /* Layers */
    #layers .layer { display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 6px; }
    /* Properties */
    #properties .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    #properties input { height: 28px; }
    /* Style */
    #style .group { display: flex; align-items: center; gap: 8px; padding: 4px 0; }
    #style label { font-size: 12px; color: var(--ink); }
    /* Resources & Export */
    #export-area { border: 1px solid var(--border); border-radius: 6px; background: var(--panel); display: flex; flex-direction: column; height: 240px; }
    #export-area header { background: var(--panel); color: var(--ink); padding: 8px; font-weight: 600; font-size: 12px; border-bottom: 1px solid var(--border); }
    #export-area textarea { flex: 1; resize: none; border: 0; padding: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 12px; background: var(--panel); color: var(--ink); }
    #export-buttons { display: flex; gap: 6px; padding: 8px; border-top: 1px solid var(--border); }
    #export-buttons button { height: 28px; }
    /* çŠ¶æ€æ  */
    #statusbar { grid-area: status; border-top: 1px solid var(--border); background: var(--panel); font-size: 12px; color: var(--ink-weak); display: flex; align-items: center; gap: 12px; padding: 4px 10px; }
  </style>
  <script src="https://unpkg.com/paper@0.12.15/dist/paper-full.min.js"></script>
</head>
<body>
  <div id="canvas-wrap">
    <aside id="left-tools" aria-label="å·¥å…·æ ">
      <button title="é€‰æ‹©" data-tool="select">ğŸ–±ï¸</button>
      <button title="æ—‹è½¬ä¸­å¿ƒ" data-tool="crosshair">âœš</button>
      <button title="é”šç‚¹" data-tool="subselect">âœ³ï¸</button>
      <button title="ç¬”åˆ·" data-tool="brush">ğŸ–Œï¸</button>
      <button title="æ©¡çš®" data-tool="eraser">ğŸ©¹</button>
      <button title="å¡«å……" data-tool="bucket">ğŸª£</button>
      <button title="æ–‡æœ¬" data-tool="text">T</button>
      <button title="ç›´çº¿" data-tool="line">ï¼</button>
      <button title="çŸ©å½¢" data-tool="rectangle">â–­</button>
      <button title="æ¤­åœ†" data-tool="ellipse">â—¯</button>
      <button title="å¤šè¾¹å½¢" data-tool="polygon" disabled>â¬ </button>
    </aside>
    <section id="canvas-pane">
      <canvas id="paper-canvas" resize></canvas>
      <canvas id="raster-canvas"></canvas>
    </section>
    <aside id="right-pane">
      <div id="tabbar">
        <button data-tab="layers" class="active">å›¾å±‚</button>
        <button data-tab="properties">å±æ€§</button>
        <button data-tab="style">æ ·å¼</button>
        <button data-tab="align">å¯¹é½</button>
        <button data-tab="shapeops">å½¢çŠ¶</button>
        <button data-tab="view">è§†å›¾</button>
        <button data-tab="resources">èµ„æº</button>
        <button data-tab="mode">æ¨¡å¼</button>
        <button data-tab="export">å¯¼å‡º</button>
      </div>
      <div id="panels">
        <div id="layers" class="panel active">
          <div style="display:flex; gap:8px; margin-bottom:8px;">
            <button id="add-layer">æ–°å›¾å±‚</button>
            <button id="btn-delete">åˆ é™¤é€‰ä¸­å¯¹è±¡</button>
            <button id="delete-layer" style="margin-left:auto">åˆ é™¤å½“å‰å›¾å±‚</button>
          </div>
          <div id="layer-list"></div>
        </div>
        <div id="properties" class="panel">
          <div class="row">
            <input placeholder="X" aria-label="x" />
            <input placeholder="Y" aria-label="y" />
          </div>
          <div class="row" style="margin-top:8px">
            <input placeholder="W" aria-label="w" />
            <input placeholder="H" aria-label="h" />
          </div>
          <div class="row" style="margin-top:8px">
            <input id="center-x" placeholder="ä¸­å¿ƒX" aria-label="center-x" />
            <input id="center-y" placeholder="ä¸­å¿ƒY" aria-label="center-y" />
          </div>
        </div>
        <div id="style" class="panel">
          <div class="group">
            <label>Fill</label>
            <input id="fill-color" type="color" value="#4f9cf7" />
          </div>
          <div class="group">
            <label>Outline</label>
            <input id="stroke-color" type="color" value="#333333" />
          </div>
          <div class="group">
            <label>Width</label>
            <input id="stroke-width" type="number" min="1" max="64" step="1" value="4" style="width:70px" />
          </div>
          <div class="group">
            <label>ç«¯ç‚¹</label>
            <select id="cap-select">
              <option value="butt">å¹³</option>
              <option value="round" selected>åœ†</option>
              <option value="square">æ–¹</option>
            </select>
          </div>
          <div class="group">
            <label>æ‹è§’</label>
            <select id="join-select">
              <option value="miter" selected>æ–œ</option>
              <option value="round">åœ†</option>
              <option value="bevel">æ–œåˆ‡</option>
            </select>
          </div>
          <div class="group">
            <label>è™šçº¿</label>
            <input id="dash-input" placeholder="6,4" style="width:90px" />
          </div>
          <div class="group">
            <label>ç®­å¤´</label>
            <label><input type="checkbox" id="arrow-start"> èµ·</label>
            <label><input type="checkbox" id="arrow-end" checked> æœ«</label>
          </div>
        </div>
        <div id="align" class="panel">
          <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:8px;">
            <button id="align-left">å·¦å¯¹é½</button>
            <button id="align-center-x">æ°´å¹³å±…ä¸­</button>
            <button id="align-right">å³å¯¹é½</button>
            <button id="align-top">é¡¶å¯¹é½</button>
            <button id="align-center-y">å‚ç›´å±…ä¸­</button>
            <button id="align-bottom">åº•å¯¹é½</button>
          </div>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button id="distribute-h">æ°´å¹³ç­‰è·</button>
            <button id="distribute-v">å‚ç›´ç­‰è·</button>
          </div>
        </div>
        <div id="shapeops" class="panel">
          <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:8px;">
            <button id="op-unite">åˆå¹¶</button>
            <button id="op-intersect">ç›¸äº¤</button>
            <button id="op-subtract">ç›¸å‡</button>
            <button id="op-exclude">æ’é™¤</button>
            <button id="op-simplify">ç®€åŒ–</button>
          </div>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button id="group">ç»„åˆ</button>
            <button id="ungroup">å–æ¶ˆç»„åˆ</button>
          </div>
        </div>
        <div id="view" class="panel">
          <div style="display:flex; align-items:center; gap:8px;">
            <label><input type="checkbox" id="snap-toggle"> å¸é™„åˆ°ç½‘æ ¼</label>
            <label>ç½‘æ ¼å°ºå¯¸ <input type="number" id="grid-size" min="2" max="100" step="2" value="24" style="width:70px"></label>
          </div>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button id="zoom-in">æ”¾å¤§</button>
            <button id="zoom-out">ç¼©å°</button>
            <button id="zoom-reset">é‡ç½®ç¼©æ”¾</button>
          </div>
        </div>
        <div id="resources" class="panel">
          <button id="import-svg">å¯¼å…¥SVG</button>
          <input id="file-input" type="file" accept="image/svg+xml" style="display:none" />
          <button id="clear" style="margin-left:8px">æ¸…ç©ºç”»å¸ƒ</button>
          <div style="margin-top:8px; display:flex; gap:8px;">
            <button id="undo">æ’¤é”€</button>
            <button id="redo">é‡åš</button>
          </div>
        </div>
        <div id="export" class="panel">
          <div id="export-area">
            <header>å¯¼å‡ºï¼ˆSVG/PNGï¼‰</header>
            <div style="display:flex; gap:12px; padding:8px; border-bottom:1px solid var(--border);">
              <div>
                <label><input type="radio" name="exp-bounds" value="content" checked> å†…å®¹è¾¹ç•Œ</label>
              </div>
              <div>
                <label><input type="radio" name="exp-bounds" value="view"> è§†å›¾å°ºå¯¸</label>
              </div>
              <div style="margin-left:auto">
                <button id="btn-finish">å®Œæˆå¹¶è¿”å›</button>
              </div>
            </div>
            <textarea id="export-text" placeholder="ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ç”Ÿæˆå¯¼å‡ºå†…å®¹..."></textarea>
            <div id="export-buttons">
              <button id="export-svg">å¯¼å‡ºSVG</button>
              <button id="export-png">å¯¼å‡ºPNG</button>
              <a id="download-link" download="drawing.svg" style="margin-left:auto">ä¸‹è½½</a>
            </div>
          </div>
        </div>
        <div id="mode" class="panel">
          <div style="display:flex; gap:8px;">
            <button id="mode-vector" class="active">çŸ¢é‡æ¨¡å¼</button>
            <button id="mode-bitmap">ä½å›¾æ¨¡å¼</button>
          </div>
          <p style="font-size:12px;color:var(--ink-weak);margin-top:8px;">çŸ¢é‡æ¨¡å¼ä½¿ç”¨ Paper.js è¿›è¡Œè·¯å¾„ç¼–è¾‘ï¼›ä½å›¾æ¨¡å¼æä¾›åŸºç¡€ç”»ç¬”/æ©¡çš®å¹¶ä»¥ PNG å¯¼å‡ºã€‚</p>
        </div>
      </div>
    </aside>
    <div id="statusbar">åæ ‡: â€” , å°ºå¯¸: â€” Ã— â€” , ç¼©æ”¾: 100%</div>
  </div>

  <script>
    // åˆå§‹åŒ– Paper.js
    const canvas = document.getElementById('paper-canvas');
    const rasterCanvas = document.getElementById('raster-canvas');
    paper.setup(canvas);

    // å½“å‰æ ·å¼
    const style = {
      strokeColor: new paper.Color(document.getElementById('stroke-color').value),
      fillColor: new paper.Color(document.getElementById('fill-color').value),
      strokeWidth: parseInt(document.getElementById('stroke-width').value, 10) || 3,
      strokeCap: document.getElementById('cap-select') ? document.getElementById('cap-select').value : 'round',
      strokeJoin: document.getElementById('join-select') ? document.getElementById('join-select').value : 'miter',
      dashArray: [],
      arrowStart: document.getElementById('arrow-start') ? document.getElementById('arrow-start').checked : false,
      arrowEnd: document.getElementById('arrow-end') ? document.getElementById('arrow-end').checked : false
    };

    function updateStyleFromUI() {
      style.strokeColor = new paper.Color(document.getElementById('stroke-color').value);
      style.fillColor = new paper.Color(document.getElementById('fill-color').value);
      style.strokeWidth = parseInt(document.getElementById('stroke-width').value, 10) || 3;
      style.strokeCap = document.getElementById('cap-select').value;
      style.strokeJoin = document.getElementById('join-select').value;
      const dashStr = document.getElementById('dash-input').value.trim();
      style.dashArray = dashStr ? dashStr.split(',').map(s => parseFloat(s) || 0).filter(n => n > 0) : [];
      style.arrowStart = document.getElementById('arrow-start').checked;
      style.arrowEnd = document.getElementById('arrow-end').checked;
    }

    document.getElementById('stroke-color').addEventListener('input', updateStyleFromUI);
    document.getElementById('fill-color').addEventListener('input', updateStyleFromUI);
    document.getElementById('stroke-width').addEventListener('change', updateStyleFromUI);
    document.getElementById('cap-select').addEventListener('change', updateStyleFromUI);
    document.getElementById('join-select').addEventListener('change', updateStyleFromUI);
    document.getElementById('dash-input').addEventListener('input', updateStyleFromUI);
    document.getElementById('arrow-start').addEventListener('change', updateStyleFromUI);
    document.getElementById('arrow-end').addEventListener('change', updateStyleFromUI);

    // UIå±‚ä¸æ—‹è½¬ä¸­å¿ƒ
    const uiLayer = new paper.Layer({ name: '__ui__' });
    uiLayer.locked = true;
    const defaultLayer = paper.project.layers[0];
    if (defaultLayer) defaultLayer.activate();
    let rotationCenter = paper.view.center.clone();
    let showCrosshair = false; // é»˜è®¤éšè—åå­—æ¶
    const cxInput = document.getElementById('center-x');
    const cyInput = document.getElementById('center-y');
    function drawCrosshair() {
      if (!showCrosshair) return;
      const prev = paper.project.activeLayer;
      uiLayer.activate();
      uiLayer.removeChildren();
      const clr = new paper.Color('#6f61ef');
      const v = new paper.Path.Line(new paper.Point(rotationCenter.x, 0), new paper.Point(rotationCenter.x, paper.view.size.height));
      v.strokeColor = clr; v.dashArray = [6,4]; v.strokeWidth = 1;
      const h = new paper.Path.Line(new paper.Point(0, rotationCenter.y), new paper.Point(paper.view.size.width, rotationCenter.y));
      h.strokeColor = clr; h.dashArray = [6,4]; h.strokeWidth = 1;
      const dot = new paper.Shape.Circle({ center: rotationCenter, radius: 5, strokeColor: clr });
      prev.activate();
    }
    function setRotationCenter(p) {
      rotationCenter = p;
      if (cxInput) cxInput.value = Math.round(p.x);
      if (cyInput) cyInput.value = Math.round(p.y);
      drawCrosshair();
    }
    if (cxInput && cyInput) {
      cxInput.addEventListener('change', () => setRotationCenter(new paper.Point(parseFloat(cxInput.value) || 0, rotationCenter.y)));
      cyInput.addEventListener('change', () => setRotationCenter(new paper.Point(rotationCenter.x, parseFloat(cyInput.value) || 0)));
    }
    // åˆå§‹ä¸ç»˜åˆ¶åå­—æ¶ï¼Œä»…è®°å½•ä¸­å¿ƒ
    setRotationCenter(rotationCenter);

    // å†å²å †æ ˆï¼ˆæ’¤é”€/é‡åšï¼‰
    const history = [];
    const redoStack = [];
    function snapshot() {
      return {
        json: paper.project.exportJSON({ asString: true }),
        rc: { x: rotationCenter.x, y: rotationCenter.y }
      };
    }
    function restore(snap) {
      if (!snap) return;
      paper.project.clear();
      paper.project.importJSON(snap.json);
      setRotationCenter(new paper.Point(snap.rc.x, snap.rc.y));
      renderLayers();
      paper.view.update();
    }
    function pushHistory() { history.push(snapshot()); redoStack.length = 0; }

    // å¯¼å‡ºä¸ºå¸¦æœ‰ Snap å…ƒä¿¡æ¯çš„ SVG
    function exportSnapSVG(boundsOpt) {
      const mode = boundsOpt || document.querySelector('input[name="exp-bounds"]:checked').value;
      const items = [];
      paper.project.layers.forEach(layer => {
        if (layer === uiLayer) return;
        layer.children.forEach(ch => { if (ch.visible) items.push(ch); });
      });
      let bounds = null;
      if (mode === 'content') {
        items.forEach(it => { bounds = bounds ? bounds.unite(it.bounds) : it.bounds.clone(); });
        if (!bounds) { bounds = new paper.Rectangle(new paper.Point(0,0), paper.view.size); }
      } else {
        bounds = new paper.Rectangle(new paper.Point(0,0), paper.view.size);
      }
      const xmlns = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(xmlns, 'svg');
      svg.setAttribute('xmlns', xmlns);
      svg.setAttribute('version', '1.1');
      // ä½¿ç”¨åˆæ³•å€¼é¿å…æŸäº›æµè§ˆå™¨/è§£æå™¨å¿½ç•¥æˆ–å¼‚å¸¸ç¼©æ”¾
      svg.setAttribute('preserveAspectRatio', 'none');
      try { svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink'); } catch(_) {}
      svg.setAttribute('snap', 'http://snap.berkeley.edu/run');
      const vb = `${bounds.left} ${bounds.top} ${bounds.width} ${bounds.height}`;
      svg.setAttribute('viewBox', vb);
      svg.setAttribute('width', bounds.width);
      svg.setAttribute('height', bounds.height);
      items.forEach(it => {
        const el = it.exportSVG({ matchShapes: true });
        const proto = (it.data && it.data.prototype) ? it.data.prototype : (
          it.className === 'PointText' ? 'VectorText' : 'VectorShape'
        );
        try { el.setAttribute('prototype', proto); } catch (_) {}
        svg.appendChild(el);
      });
      const serializer = new XMLSerializer();
      return serializer.serializeToString(svg);
    }

    // åˆ†å›¾å±‚å¯¼å‡ºï¼šè¿”å›æ¯ä¸ªå›¾å±‚ï¼ˆä¸å« UI å±‚ï¼‰çš„ç‹¬ç«‹ SVG å­—ç¬¦ä¸²
    function exportLayersSVG(boundsOpt){
      const mode = boundsOpt || document.querySelector('input[name="exp-bounds"]:checked').value;
      const results = [];
      const xmlns = 'http://www.w3.org/2000/svg';
      paper.project.layers.forEach(layer => {
        if (!layer || layer === uiLayer) return;
        const items = layer.children.filter(ch => ch && ch.visible);
        if (!items.length) { results.push(''); return; }
        // è®¡ç®—è¾¹ç•Œ
        let bounds = null;
        if (mode === 'content') {
          items.forEach(it => { bounds = bounds ? bounds.unite(it.bounds) : it.bounds.clone(); });
        } else {
          bounds = new paper.Rectangle(new paper.Point(0,0), paper.view.size);
        }
        const svg = document.createElementNS(xmlns, 'svg');
        svg.setAttribute('xmlns', xmlns);
        svg.setAttribute('version', '1.1');
        svg.setAttribute('preserveAspectRatio', 'none meet');
        svg.setAttribute('snap', 'http://snap.berkeley.edu/run');
        const vb = `${bounds.left} ${bounds.top} ${bounds.width} ${bounds.height}`;
        svg.setAttribute('viewBox', vb);
        svg.setAttribute('width', bounds.width);
        svg.setAttribute('height', bounds.height);
        items.forEach(it => {
          const el = it.exportSVG({ matchShapes: true });
          const proto = (it.data && it.data.prototype) ? it.data.prototype : (
            it.className === 'PointText' ? 'VectorText' : 'VectorShape'
          );
          try { el.setAttribute('prototype', proto); } catch (_) {}
          svg.appendChild(el);
        });
        const serializer = new XMLSerializer();
        results.push(serializer.serializeToString(svg));
      });
      return results;
    }

    // ç®­å¤´è¾…åŠ©ï¼šç»˜åˆ¶ä¸è”åŠ¨æ›´æ–°
    function addArrowheads(line, style) {
      const segs = line.segments;
      if (!segs || segs.length < 2) return [];
      const start = segs[0].point;
      const end = segs[segs.length - 1].point;
      const v = end.subtract(start);
      const len = Math.max(1, v.length);
      const dir = v.divide(len);
      const size = Math.max(6, style.strokeWidth * 2);
      const half = size * 0.6;

      function triangleAt(tip, direction) {
        const base = tip.subtract(direction.multiply(size));
        const perp = new paper.Point(-direction.y, direction.x).multiply(half);
        const tri = new paper.Path({ closed: true, fillColor: style.strokeColor, strokeColor: null });
        tri.add(tip);
        tri.add(base.add(perp));
        tri.add(base.subtract(perp));
        tri.data = tri.data || {}; tri.data.prototype = 'VectorPolygon';
        return tri;
      }

      const refs = [];
      if (style.arrowStart) refs.push(triangleAt(start, dir));
      if (style.arrowEnd) refs.push(triangleAt(end, dir));
      line.data = line.data || {};
      line.data.arrowRefs = refs;
      line.data.arrowStyle = {
        arrowStart: !!style.arrowStart,
        arrowEnd: !!style.arrowEnd,
        size,
        color: style.strokeColor,
        strokeWidth: style.strokeWidth
      };
      return refs;
    }

    function updateArrowheadsForLine(line) {
      if (!line || !line.segments || line.segments.length < 2) return;
      const styleInfo = (line.data && line.data.arrowStyle) || {
        arrowStart: false,
        arrowEnd: false,
        strokeWidth: line.strokeWidth || 2,
        strokeColor: line.strokeColor || new paper.Color('black')
      };
      // æ¸…é™¤æ—§å¼•ç”¨
      if (line.data && Array.isArray(line.data.arrowRefs)) {
        line.data.arrowRefs.forEach(ref => { try { ref.remove(); } catch (_) {} });
        line.data.arrowRefs = [];
      }
      // é‡æ–°åˆ›å»º
      addArrowheads(line, {
        arrowStart: styleInfo.arrowStart,
        arrowEnd: styleInfo.arrowEnd,
        strokeWidth: styleInfo.strokeWidth,
        strokeColor: styleInfo.color || styleInfo.strokeColor
      });
    }

    // å·¥å…·å®ç°
    let currentToolName = 'select';
    let currentTool = new paper.Tool();
    let activeItem = null; // é€‰æ‹©æ¨¡å¼ä¸‹æ´»åŠ¨å…ƒç´ 
    let dragStart = null;
    let selectingStart = null;
    let selectingRect = null;
    let isSelecting = false;

    // è§†å›¾ä¸å¸é™„
    let snapToGrid = false;
    let gridSize = parseInt(document.getElementById('grid-size').value, 10) || 24;
    document.getElementById('snap-toggle').addEventListener('change', (e) => { snapToGrid = e.target.checked; });
    document.getElementById('grid-size').addEventListener('change', (e) => { gridSize = Math.max(2, parseInt(e.target.value, 10) || 24); });

    function snapPoint(p) {
      if (!snapToGrid) return p;
      return new paper.Point(
        Math.round(p.x / gridSize) * gridSize,
        Math.round(p.y / gridSize) * gridSize
      );
    }

    // å›¾å±‚é¢æ¿æ¸²æŸ“ä¸äº¤äº’
    function renderLayers() {
      const list = document.getElementById('layer-list');
      if (!list) return;
      list.innerHTML = '';
      paper.project.layers.forEach((layer, idx) => {
        const row = document.createElement('div');
        row.className = 'layer';
        const name = document.createElement('span');
        name.textContent = layer.name || ('Layer ' + (idx + 1));
        name.contentEditable = true;
        name.addEventListener('input', () => { layer.name = name.textContent; });

        const controls = document.createElement('span');
        const btnEye = document.createElement('button');
        btnEye.title = 'æ˜¾ç¤º/éšè—';
        btnEye.textContent = layer.visible ? 'ğŸ‘ï¸' : 'ğŸš«';
        btnEye.addEventListener('click', () => { layer.visible = !layer.visible; renderLayers(); paper.view.update(); });

        const btnLock = document.createElement('button');
        btnLock.title = 'é”å®š/è§£é”';
        btnLock.textContent = layer.locked ? 'ğŸ”’' : 'ğŸ”“';
        btnLock.addEventListener('click', () => { layer.locked = !layer.locked; renderLayers(); });

        const btnUp = document.createElement('button');
        btnUp.title = 'ä¸Šç§»';
        btnUp.textContent = 'â–²';
        btnUp.addEventListener('click', () => {
          if (idx > 0) {
            const above = paper.project.layers[idx - 1];
            layer.insertAbove(above);
            renderLayers();
            paper.view.update();
          }
        });

        const btnDown = document.createElement('button');
        btnDown.title = 'ä¸‹ç§»';
        btnDown.textContent = 'â–¼';
        btnDown.addEventListener('click', () => {
          if (idx < paper.project.layers.length - 1) {
            const below = paper.project.layers[idx + 1];
            layer.insertBelow(below);
            renderLayers();
            paper.view.update();
          }
        });

        controls.appendChild(btnEye);
        controls.appendChild(btnLock);
        controls.appendChild(btnUp);
        controls.appendChild(btnDown);

        row.appendChild(name);
        row.appendChild(controls);
        row.addEventListener('click', () => { layer.activate(); renderLayers(); });
        if (paper.project.activeLayer === layer) {
          row.style.outline = '2px solid var(--accent)';
        }
        list.appendChild(row);
      });
    }

    function setTool(name) {
      currentTool.remove();
      currentTool = new paper.Tool();
      currentToolName = name;
      activeItem = null;
      dragStart = null;

      if (name === 'select') {
        currentTool.onMouseDown = (event) => {
          const hit = paper.project.hitTest(snapPoint(event.point), {
            fill: true,
            stroke: true,
            segments: true,
            tolerance: 6
          });
          if (hit && hit.item) {
            activeItem = hit.item;
            activeItem.selected = true;
            dragStart = event.point;
            isSelecting = false;
          } else {
            paper.project.activeLayer.selected = false;
            paper.project.activeLayer.children.forEach(ch => ch.selected = false);
            activeItem = null;
            // å¼€å§‹æ¡†é€‰
            isSelecting = true;
            selectingStart = snapPoint(event.point);
            const prev = paper.project.activeLayer;
            uiLayer.activate();
            const r = new paper.Rectangle(selectingStart, selectingStart);
            selectingRect = new paper.Shape.Rectangle({ rectangle: r, strokeColor: new paper.Color('#6b7280'), dashArray: [4,4], strokeWidth: 1 });
            prev.activate();
          }
        };
        currentTool.onMouseDrag = (event) => {
          if (activeItem) {
            const target = snapPoint(activeItem.position.add(event.delta));
            const deltaVec = target.subtract(activeItem.position);
            activeItem.position = target;
            // è”åŠ¨ç®­å¤´ï¼šæŒ‰ç«¯ç‚¹ä¸æ–¹å‘é‡ç®—
            if (activeItem.className === 'Path' && activeItem.segments && activeItem.segments.length === 2 && activeItem.data && activeItem.data.arrowStyle) {
              updateArrowheadsForLine(activeItem);
            }
          } else if (isSelecting && selectingRect) {
            const prev = paper.project.activeLayer;
            uiLayer.activate();
            selectingRect.remove();
            const r = new paper.Rectangle(selectingStart, snapPoint(event.point));
            selectingRect = new paper.Shape.Rectangle({ rectangle: r, strokeColor: new paper.Color('#6b7280'), dashArray: [4,4], strokeWidth: 1 });
            prev.activate();
          }
        };
        currentTool.onMouseUp = (event) => {
          dragStart = null;
          if (isSelecting && selectingRect) {
            const rect = selectingRect.rectangle || new paper.Rectangle(selectingStart, snapPoint(event.point));
            selectingRect.remove();
            isSelecting = false;
            // é€‰ä¸­ä¸çŸ©å½¢ç›¸äº¤çš„å¯¹è±¡
            paper.project.activeLayer.children.forEach(it => {
              if (it.visible && !paper.project.activeLayer.locked && it.bounds.intersects(rect)) {
                it.selected = true;
              }
            });
          }
        };
      }

      if (name === 'brush') {
        let path;
        if (currentMode === 'bitmap') {
          // åœ¨ä½å›¾æ¨¡å¼ä¸‹ï¼ŒPaper.js äº‹ä»¶ç‚¹ä¸ºâ€œå·¥ç¨‹åæ ‡â€ï¼Œ
          // éœ€è¦è½¬æ¢ä¸ºè§†å›¾åƒç´ åæ ‡å†ç»˜åˆ¶åˆ°ä½å›¾ç”»å¸ƒï¼Œä»¥é¿å…åç§»/ç¼©æ”¾è¯¯å·®ã€‚
          const toView = (pt) => paper.view.projectToView(pt);
          currentTool.onMouseDown = (event) => {
            updateStyleFromUI(); ensureRasterSize();
            rctx.globalCompositeOperation = 'source-over';
            rctx.strokeStyle = style.strokeColor.toCSS(true);
            rctx.lineWidth = style.strokeWidth;
            rctx.lineJoin = style.strokeJoin;
            rctx.lineCap = style.strokeCap;
            const v = toView(event.point);
            rctx.beginPath(); rctx.moveTo(v.x, v.y);
          };
          currentTool.onMouseDrag = (event) => {
            const v = toView(event.point);
            rctx.lineTo(v.x, v.y); rctx.stroke();
          };
          currentTool.onMouseUp = () => { rctx.closePath(); };
        } else {
          currentTool.onMouseDown = (event) => {
            updateStyleFromUI();
            path = new paper.Path({
              strokeColor: style.strokeColor,
              strokeWidth: style.strokeWidth,
              fullySelected: false,
              strokeCap: style.strokeCap,
              strokeJoin: style.strokeJoin,
              dashArray: style.dashArray
            });
            path.add(snapPoint(event.point));
          };
          currentTool.onMouseDrag = (event) => { if (path) { path.add(snapPoint(event.point)); } };
          currentTool.onMouseUp = () => {
            if (path) {
              path.simplify(5);
              path.data = path.data || {}; path.data.prototype = 'VectorPolygon';
              pushHistory();
            }
          };
        }
      }

      if (name === 'rectangle') {
        let rect; let start;
        currentTool.onMouseDown = (event) => { start = snapPoint(event.point); };
        currentTool.onMouseDrag = (event) => {
          updateStyleFromUI();
          let end = snapPoint(event.point);
          if (event.event && event.event.shiftKey) {
            const dx = end.x - start.x; const dy = end.y - start.y;
            const s = Math.min(Math.abs(dx), Math.abs(dy));
            end = new paper.Point(start.x + Math.sign(dx) * s, start.y + Math.sign(dy) * s);
          }
          const r = new paper.Rectangle(start, end);
          if (rect) rect.remove();
          rect = new paper.Path.Rectangle(r);
          rect.strokeColor = style.strokeColor;
          rect.fillColor = style.fillColor;
          rect.strokeWidth = style.strokeWidth;
          rect.strokeCap = style.strokeCap;
          rect.strokeJoin = style.strokeJoin;
          rect.dashArray = style.dashArray;
        };
        currentTool.onMouseUp = () => { if (rect) { rect.data = rect.data || {}; rect.data.prototype = 'VectorRectangle'; pushHistory(); } };
      }

      if (name === 'ellipse') {
        let ell; let start;
        currentTool.onMouseDown = (event) => { start = snapPoint(event.point); };
        currentTool.onMouseDrag = (event) => {
          updateStyleFromUI();
          let end = snapPoint(event.point);
          if (event.event && event.event.shiftKey) {
            const dx = end.x - start.x; const dy = end.y - start.y;
            const s = Math.min(Math.abs(dx), Math.abs(dy));
            end = new paper.Point(start.x + Math.sign(dx) * s, start.y + Math.sign(dy) * s);
          }
          const r = new paper.Rectangle(start, end);
          if (ell) ell.remove();
          ell = new paper.Path.Ellipse(r);
          ell.strokeColor = style.strokeColor;
          ell.fillColor = style.fillColor;
          ell.strokeWidth = style.strokeWidth;
          ell.strokeCap = style.strokeCap;
          ell.strokeJoin = style.strokeJoin;
          ell.dashArray = style.dashArray;
        };
        currentTool.onMouseUp = () => { if (ell) { ell.data = ell.data || {}; ell.data.prototype = 'VectorEllipse'; pushHistory(); } };
      }

      if (name === 'line') {
        let line; let start;
        currentTool.onMouseDown = (event) => { start = snapPoint(event.point); };
        currentTool.onMouseDrag = (event) => {
          updateStyleFromUI();
          let end = snapPoint(event.point);
          if (event.event && event.event.shiftKey) {
            const delta = end.subtract(start);
            if (Math.abs(delta.x) > Math.abs(delta.y)) {
              end = new paper.Point(end.x, start.y);
            } else {
              end = new paper.Point(start.x, end.y);
            }
          }
          if (line) line.remove();
          line = new paper.Path({ strokeColor: style.strokeColor, strokeWidth: style.strokeWidth });
          line.add(start);
          line.add(end);
          line.strokeCap = style.strokeCap;
          line.strokeJoin = style.strokeJoin;
          line.dashArray = style.dashArray;
          // ç®­å¤´
          if (style.arrowStart || style.arrowEnd) {
            addArrowheads(line, style);
          }
        };
        currentTool.onMouseUp = () => { if (line) { line.data = line.data || {}; line.data.prototype = 'VectorLine'; pushHistory(); } };
      }

      if (name === 'text') {
        currentTool.onMouseDown = (event) => {
          updateStyleFromUI();
          const text = new paper.PointText({
            point: event.point,
            content: 'æ–‡æœ¬',
            fillColor: style.strokeColor,
            fontSize: 18
          });
          text.selected = true;
        };
      }

      if (name === 'crosshair') {
        currentTool.onMouseDown = (event) => {
          setRotationCenter(snapPoint(event.point));
        };
      }

      if (name === 'subselect') {
        let seg = null;
        currentTool.onMouseDown = (event) => {
          const hit = paper.project.hitTest(snapPoint(event.point), { segments: true, tolerance: 6 });
          if (hit && hit.segment) { seg = hit.segment; }
        };
        currentTool.onMouseDrag = (event) => {
          if (seg) {
            seg.point = snapPoint(event.point);
            // å¦‚æœæ˜¯ç›´çº¿çš„ç«¯ç‚¹è¢«æ‹–åŠ¨ï¼Œé‡ç®—ç®­å¤´
            const owner = seg.path;
            if (owner && owner.className === 'Path' && owner.segments && owner.segments.length === 2 && owner.data && owner.data.arrowStyle) {
              updateArrowheadsForLine(owner);
            }
          }
        };
        currentTool.onMouseUp = () => { seg = null; };
      }

      if (name === 'bucket') {
        currentTool.onMouseDown = (event) => {
          updateStyleFromUI();
          const hit = paper.project.hitTest(snapPoint(event.point), { fill: true, stroke: true, tolerance: 6 });
          if (hit && hit.item) { hit.item.fillColor = style.fillColor; pushHistory(); paper.view.update(); }
        };
      }

      if (name === 'eraser') {
        let eraserPath;
        if (currentMode === 'bitmap') {
          const toView = (pt) => paper.view.projectToView(pt);
          currentTool.onMouseDown = (event) => {
            ensureRasterSize(); updateStyleFromUI();
            rctx.globalCompositeOperation = 'destination-out';
            rctx.strokeStyle = 'rgba(0,0,0,1)';
            rctx.lineWidth = Math.max(6, style.strokeWidth);
            rctx.lineJoin = 'round'; rctx.lineCap = 'round';
            const v = toView(event.point);
            rctx.beginPath(); rctx.moveTo(v.x, v.y);
          };
          currentTool.onMouseDrag = (event) => {
            const v = toView(event.point);
            rctx.lineTo(v.x, v.y); rctx.stroke();
          };
          currentTool.onMouseUp = () => { rctx.closePath(); rctx.globalCompositeOperation = 'source-over'; };
        } else {
          currentTool.onMouseDown = (event) => {
            eraserPath = new paper.Path({ strokeColor: new paper.Color('#000'), strokeWidth: 1 });
            eraserPath.add(snapPoint(event.point));
          };
          currentTool.onMouseDrag = (event) => { eraserPath && eraserPath.add(snapPoint(event.point)); };
          currentTool.onMouseUp = () => {
            if (!eraserPath) return;
            // é—­åˆç®€åŒ–æ“¦é™¤è·¯å¾„ä»¥ç”¨äºå¸ƒå°”è¿ç®—
            try { eraserPath.closed = true; eraserPath.simplify(2); } catch (_) {}
            const items = paper.project.activeLayer.children.slice();
            items.forEach(it => {
              if (!it || it === eraserPath || it.locked || !it.visible) return;
              try {
                // å¯¹é—­åˆè·¯å¾„ï¼ˆå¡«å……å½¢çŠ¶ï¼‰åšå¸ƒå°”è£å‰ª
                if ((it instanceof paper.Path || it instanceof paper.CompoundPath) && it.closed) {
                  const res = it.subtract(eraserPath);
                  if (res) { it.remove(); paper.project.activeLayer.addChild(res); res.selected = true; }
                  return;
                }
                // å¯¹ç›´çº¿æ®µåšåˆ†æ®µæ“¦é™¤
                if (it.className === 'Path' && it.segments && it.segments.length === 2) {
                  const [s0, s1] = [it.segments[0].point, it.segments[1].point];
                  const ints = it.getIntersections(eraserPath) || [];
                  if (ints.length === 0) {
                    // å¦‚æœç«¯ç‚¹åœ¨æ“¦é™¤åŒºå†…åˆ™åˆ é™¤
                    if (eraserPath.contains(s0) || eraserPath.contains(s1)) { it.remove(); }
                    return;
                  }
                  // æŒ‰çº¿ä¸Šçš„ä½ç½®æ’åº
                  const pts = ints.map(i => i.point);
                  // åªæ”¯æŒæœ€å¤šä¸¤ä¸ªäº¤ç‚¹çš„æƒ…å†µï¼ˆå¸¸è§ï¼‰
                  const pA = pts[0], pB = pts[1] || null;
                  const newLines = [];
                  const mkLine = (a, b) => {
                    const ln = new paper.Path({ strokeColor: it.strokeColor, strokeWidth: it.strokeWidth });
                    ln.add(a); ln.add(b); ln.strokeCap = it.strokeCap; ln.strokeJoin = it.strokeJoin; ln.dashArray = it.dashArray;
                    ln.data = ln.data || {}; ln.data.prototype = 'VectorLine';
                    // ç»§æ‰¿ç®­å¤´æ ·å¼å¹¶é‡ç»˜
                    if (it.data && it.data.arrowStyle) { addArrowheads(ln, it.data.arrowStyle); }
                    return ln;
                  };
                  const s0Inside = eraserPath.contains(s0);
                  const s1Inside = eraserPath.contains(s1);
                  if (pA && !pB) {
                    // å•äº¤ç‚¹ï¼šä¿ç•™åœ¨å¤–çš„ä¸€æ®µ
                    if (!s0Inside && s1Inside) { newLines.push(mkLine(s0, pA)); }
                    else if (s0Inside && !s1Inside) { newLines.push(mkLine(pA, s1)); }
                  } else if (pA && pB) {
                    // åŒäº¤ç‚¹ï¼šå¯èƒ½äº§ç”Ÿä¸¤æ®µ
                    if (!s0Inside) newLines.push(mkLine(s0, pA));
                    if (!s1Inside) newLines.push(mkLine(pB, s1));
                  }
                  // æ›´æ–°åœºæ™¯
                  if (newLines.length) {
                    it.remove();
                    newLines.forEach(nl => { paper.project.activeLayer.addChild(nl); nl.selected = true; });
                  }
                  return;
                }
                // å…¶å®ƒå¯¹è±¡ï¼šè‹¥è¾¹ç•Œç›¸äº¤åˆ™åˆ é™¤ï¼ˆä¿å®ˆå¤„ç†ï¼‰
                if (it.bounds && eraserPath.bounds && it.bounds.intersects(eraserPath.bounds)) { it.remove(); }
              } catch (e) {
                // å¤±è´¥æ—¶é€€åŒ–ä¸ºè¾¹ç•Œæ£€æµ‹åˆ é™¤
                if (it.bounds && eraserPath.bounds && it.bounds.intersects(eraserPath.bounds)) { it.remove(); }
              }
            });
            eraserPath.remove(); pushHistory(); paper.view.update();
          };
        }
      }
    }

    // æ ‡ç­¾é¢æ¿åˆ‡æ¢
    const tabbar = document.getElementById('tabbar');
    tabbar.addEventListener('click', (e) => {
      if (e.target.tagName !== 'BUTTON') return;
      const tab = e.target.getAttribute('data-tab');
      document.querySelectorAll('#tabbar button').forEach(b => b.classList.remove('active'));
      e.target.classList.add('active');
      document.querySelectorAll('#panels .panel').forEach(p => p.classList.remove('active'));
      document.getElementById(tab).classList.add('active');
    });

    // å·¦ä¾§å·¥å…·æ äº‹ä»¶
    document.querySelectorAll('#left-tools [data-tool]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#left-tools button').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        setTool(btn.getAttribute('data-tool'));
      });
    });
    // é»˜è®¤é€‰æ‹©å·¥å…·
    document.querySelector('#left-tools [data-tool="select"]').classList.add('active');
    setTool('select');
    renderLayers();

    // å¯¼å…¥/å¯¼å‡º
    document.getElementById('clear').addEventListener('click', () => {
      paper.project.clear();
      paper.view.update();
      document.getElementById('export-text').value = '';
      pushHistory();
    });

    document.getElementById('import-svg').addEventListener('click', () => document.getElementById('file-input').click());
    document.getElementById('file-input').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const text = await file.text();
      try {
        paper.project.importSVG(text, { insert: true });
        paper.view.update();
        pushHistory();
      } catch (err) {
        alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message);
      }
    });

    document.getElementById('export-svg').addEventListener('click', () => {
      const svgString = exportSnapSVG();
      document.getElementById('export-text').value = svgString;
      const blob = new Blob([svgString], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.getElementById('download-link');
      a.href = url;
      a.textContent = 'ä¸‹è½½SVG';
      a.download = 'drawing.svg';
    });

    document.getElementById('export-png').addEventListener('click', () => {
      const dataUrl = currentMode === 'bitmap' ? rasterCanvas.toDataURL('image/png') : paper.view.element.toDataURL('image/png');
      document.getElementById('export-text').value = dataUrl;
      const a = document.getElementById('download-link');
      a.href = dataUrl;
      a.textContent = 'ä¸‹è½½PNG';
      a.download = 'drawing.png';
    });

    document.getElementById('add-layer').addEventListener('click', () => {
      const layer = new paper.Layer();
      layer.activate();
      renderLayers();
      pushHistory();
    });

    // åˆ é™¤é€‰ä¸­æŒ‰é’®
    const btnDelete = document.getElementById('btn-delete');
    if (btnDelete) {
      btnDelete.addEventListener('click', () => {
        paper.project.activeLayer.children
          .filter(ch => ch.selected)
          .forEach(ch => ch.remove());
        pushHistory();
      });
    }

    const btnDeleteLayer = document.getElementById('delete-layer');
    if (btnDeleteLayer) {
      btnDeleteLayer.addEventListener('click', () => {
        const layer = paper.project.activeLayer;
        if (paper.project.layers.length <= 1) { return; }
        const idx = paper.project.layers.indexOf(layer);
        const target = idx > 0 ? paper.project.layers[idx - 1] : paper.project.layers[idx + 1];
        layer.remove();
        if (target) target.activate();
        renderLayers();
        paper.view.update();
        pushHistory();
      });
    }

    // å¯¹é½ä¸åˆ†å¸ƒ
    function getSelection() {
      return paper.project.activeLayer.children.filter(ch => ch.selected);
    }
    function getBounds(items) {
      if (!items.length) return null;
      let rect = items[0].bounds.clone();
      for (let i = 1; i < items.length; i++) {
        rect = rect.unite(items[i].bounds);
      }
      return rect;
    }
    function align(direction) {
      const items = getSelection();
      const b = getBounds(items);
      if (!b) return;
      items.forEach(it => {
        const ib = it.bounds;
        let x = it.position.x, y = it.position.y;
        if (direction === 'left') x = b.left + ib.width / 2;
        if (direction === 'center-x') x = b.center.x;
        if (direction === 'right') x = b.right - ib.width / 2;
        if (direction === 'top') y = b.top + ib.height / 2;
        if (direction === 'center-y') y = b.center.y;
        if (direction === 'bottom') y = b.bottom - ib.height / 2;
        it.position = new paper.Point(x, y);
      });
      paper.view.update();
    }
    function distribute(axis) {
      const items = getSelection();
      if (items.length < 3) return; // è‡³å°‘3ä¸ªå¯¹è±¡
      items.sort((a, b) => axis === 'h' ? a.bounds.left - b.bounds.left : a.bounds.top - b.bounds.top);
      const b = getBounds(items);
      const step = axis === 'h' ? b.width / (items.length - 1) : b.height / (items.length - 1);
      items.forEach((it, i) => {
        const pos = axis === 'h' ? new paper.Point(b.left + step * i, it.position.y) : new paper.Point(it.position.x, b.top + step * i);
        it.position = pos;
      });
      paper.view.update();
    }
    document.getElementById('align-left').addEventListener('click', () => align('left'));
    document.getElementById('align-center-x').addEventListener('click', () => align('center-x'));
    document.getElementById('align-right').addEventListener('click', () => align('right'));
    document.getElementById('align-top').addEventListener('click', () => align('top'));
    document.getElementById('align-center-y').addEventListener('click', () => align('center-y'));
    document.getElementById('align-bottom').addEventListener('click', () => align('bottom'));
    document.getElementById('distribute-h').addEventListener('click', () => distribute('h'));
    document.getElementById('distribute-v').addEventListener('click', () => distribute('v'));

    // å¸ƒå°”è¿ç®—ä¸ç»„åˆ
    function pathItemsOfSelection() {
      return getSelection().filter(it => it instanceof paper.Path || it instanceof paper.CompoundPath);
    }
    function pathOp(op) {
      const items = pathItemsOfSelection();
      if (items.length < 2) return;
      let result = items[0];
      for (let i = 1; i < items.length; i++) {
        try {
          let res;
          if (op === 'unite') res = result.unite(items[i]);
          if (op === 'intersect') res = result.intersect(items[i]);
          if (op === 'subtract') res = result.subtract(items[i]);
          if (op === 'exclude') res = result.exclude(items[i]);
          result.remove();
          result = res;
        } catch (e) { console.warn('Path op error', e); }
      }
      items.forEach((it, idx) => { if (idx > 0) it.remove(); });
      result.selected = true;
      paper.project.activeLayer.addChild(result);
      paper.view.update();
    }
    document.getElementById('op-unite').addEventListener('click', () => pathOp('unite'));
    document.getElementById('op-intersect').addEventListener('click', () => pathOp('intersect'));
    document.getElementById('op-subtract').addEventListener('click', () => pathOp('subtract'));
    document.getElementById('op-exclude').addEventListener('click', () => pathOp('exclude'));
    document.getElementById('op-simplify').addEventListener('click', () => {
      pathItemsOfSelection().forEach(p => p.simplify(2));
      paper.view.update();
    });
    document.getElementById('group').addEventListener('click', () => {
      const items = getSelection();
      if (!items.length) return;
      const g = new paper.Group(items);
      g.selected = true;
      paper.view.update();
    });
    document.getElementById('ungroup').addEventListener('click', () => {
      const items = getSelection();
      items.forEach(it => {
        if (it instanceof paper.Group) {
          it.children.forEach(ch => { ch.selected = true; paper.project.activeLayer.addChild(ch); });
          it.remove();
        }
      });
      paper.view.update();
    });

    // å¿«æ·é”®ï¼šDelete åˆ é™¤é€‰ä¸­
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Delete') {
        paper.project.activeLayer.children
          .filter(ch => ch.selected)
          .forEach(ch => ch.remove());
        pushHistory();
      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
        window.__clipboard = paper.project.activeLayer.children.filter(ch => ch.selected).map(it => it.clone());
      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') {
        const offset = new paper.Point(10, 10);
        (window.__clipboard || []).forEach(clone => { clone.position = clone.position.add(offset); paper.project.activeLayer.addChild(clone); });
        paper.view.update();
        pushHistory();
      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
        const snap = history.pop();
        if (snap) { redoStack.push(snapshot()); restore(snap); }
      } else if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y')) {
        const snap = redoStack.pop();
        if (snap) { history.push(snapshot()); restore(snap); }
      } else if ((e.ctrlKey || e.metaKey) && e.key === ']') {
        paper.project.activeLayer.children.filter(ch => ch.selected).forEach(ch => ch.bringToFront());
        pushHistory();
      } else if ((e.ctrlKey || e.metaKey) && e.key === '[') {
        paper.project.activeLayer.children.filter(ch => ch.selected).forEach(ch => ch.sendToBack());
        pushHistory();
      }
    });

    // ç¼©æ”¾æ§åˆ¶
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomResetBtn = document.getElementById('zoom-reset');
    if (zoomInBtn) zoomInBtn.addEventListener('click', () => { paper.view.zoom *= 1.1; paper.view.update(); });
    if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => { paper.view.zoom /= 1.1; paper.view.update(); });
    if (zoomResetBtn) zoomResetBtn.addEventListener('click', () => { paper.view.zoom = 1; paper.view.update(); });

    // çŠ¶æ€æ è”åŠ¨
    function updateStatusFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      // å°†è§†å›¾åƒç´ æŒ‰ CSS ä¸è§†å›¾å°ºå¯¸æ¯”ä¾‹è½¬æ¢ï¼Œé¿å…åç§»/ç¼©æ”¾è¯¯å·®
      const scaleX = paper.view.size.width / rect.width;
      const scaleY = paper.view.size.height / rect.height;
      const viewPt = new paper.Point((e.clientX - rect.left) * scaleX, (e.clientY - rect.top) * scaleY);
      const projPt = paper.view.viewToProject(viewPt);
      const selCount = paper.project.selectedItems ? paper.project.selectedItems.length : paper.project.activeLayer.children.filter(ch => ch.selected).length;
      const zoom = Math.round(paper.view.zoom * 100);
      document.getElementById('statusbar').textContent = `åæ ‡: ${Math.round(projPt.x)}, ${Math.round(projPt.y)} , é€‰ä¸­: ${selCount} , ç¼©æ”¾: ${zoom}%`;
    }
    document.addEventListener('mousemove', updateStatusFromEvent);

    // è§†å›¾æ›´æ–°
    paper.view.onResize = () => paper.view.update();
    // æ’¤é”€/é‡åšæŒ‰é’®ï¼ˆä¿æŒåœ¨ä¸»è„šæœ¬å†…ï¼‰
    document.getElementById('undo').addEventListener('click', () => {
      const snap = history.pop();
      if (snap) { redoStack.push(snapshot()); restore(snap); }
    });
    document.getElementById('redo').addEventListener('click', () => {
      const snap = redoStack.pop();
      if (snap) { history.push(snapshot()); restore(snap); }
    });

    // å®Œæˆå¹¶è¿”å›ï¼ˆåµŒå…¥æ¨¡å¼æ¡¥æ¥ï¼‰
    document.getElementById('btn-finish').addEventListener('click', () => {
      try {
        let payload;
        if (currentMode === 'bitmap') {
          ensureRasterSize();
          const dataUrl = rasterCanvas.toDataURL('image/png');
          payload = { type: 'snap-paint-result', kind: 'bitmap', png: dataUrl, center: { x: rotationCenter.x, y: rotationCenter.y } };
        } else {
          const svgString = exportSnapSVG();
          const layers = exportLayersSVG();
          payload = { type: 'snap-paint-result', kind: 'vector', svg: svgString, layers: layers, center: { x: rotationCenter.x, y: rotationCenter.y } };
        }
        window.parent && window.parent.postMessage(payload, '*');
      } catch (e) { console.warn('postMessage error', e); }
    });

    // æ¥æ”¶çˆ¶çª—å£çš„åˆå§‹åŒ–æ¶ˆæ¯ï¼ˆä¿æŒåœ¨ä¸»è„šæœ¬å†…ï¼‰
    window.addEventListener('message', (ev) => {
      const msg = ev.data || {};
      if (msg.type === 'snap-paint-init') {
        try {
          // ä¸»é¢˜åº”ç”¨ï¼šæ ¹æ® IDE ä¼ å…¥çš„ä¸»é¢˜è®¾ç½® CSS å˜é‡
          if (msg.theme) {
            const t = msg.theme;
            const root = document.documentElement.style;
            // ç®€å•äº®/æš—åˆ¤æ–­ï¼šå–èƒŒæ™¯çš„è¿‘ä¼¼äº®åº¦
            function parseRGB(s){
              if(!s) return [246,247,249];
              if(/^#/.test(s)){
                const h = s.replace('#','');
                const n = h.length===3? h.split('').map(c=>parseInt(c+c,16)) : [parseInt(h.slice(0,2),16), parseInt(h.slice(2,4),16), parseInt(h.slice(4,6),16)];
                return n;
              }
              const m = s.match(/(\d+)[^\d]+(\d+)[^\d]+(\d+)/); return m? [parseInt(m[1],10),parseInt(m[2],10),parseInt(m[3],10)] : [246,247,249];
            }
            const [r,g,b] = parseRGB(t.backgroundColor || t.frameColor);
            const lum = (0.299*r + 0.587*g + 0.114*b)/255; // 0=dark,1=light
            const isDark = lum < 0.5;
            root.setProperty('--bg', t.backgroundColor || (isDark? '#1e1e1e' : '#f6f7f9'));
            root.setProperty('--panel', t.groupColor || t.frameColor || (isDark? '#2b2b2b' : '#ffffff'));
            root.setProperty('--border', isDark? '#3c3c3c' : '#e5e7eb');
            root.setProperty('--ink', isDark? '#f5f5f5' : '#222');
            root.setProperty('--ink-weak', isDark? '#b5b5b5' : '#6b7280');
            root.setProperty('--accent', t.titleBarColor || '#6f61ef');
            root.setProperty('--accent-ink', t.titleTextColor || (isDark? '#ffffff' : '#000000'));
          }
          if (msg.size && msg.size.width && msg.size.height) {
            // è®¾ç½®å†…éƒ¨åƒç´ å°ºå¯¸ä¸ CSS å°ºå¯¸ä¸€è‡´ï¼Œç¡®ä¿åæ ‡ç²¾ç¡®
            canvas.width = msg.size.width; canvas.height = msg.size.height;
            canvas.style.width = msg.size.width + 'px';
            canvas.style.height = msg.size.height + 'px';
            // æç¤º Paper ä½¿ç”¨åŒæ ·çš„è§†å›¾å°ºå¯¸
            paper.view.setViewSize(new paper.Size(msg.size.width, msg.size.height));
            try { paper.view.pixelRatio = Math.max(1, window.devicePixelRatio || 1); } catch(_) {}
            ensureRasterSize();
          }
          if (msg.svg) {
            // æ¸…ç©ºå½“å‰é¡¹ç›®å¹¶å¯¼å…¥ä¼ å…¥çš„SVG
            paper.project.clear();
            paper.project.importSVG(msg.svg, { insert: true });
            renderLayers(); paper.view.update();
          }
          if (msg.center && typeof msg.center.x === 'number' && typeof msg.center.y === 'number') {
            setRotationCenter(new paper.Point(msg.center.x, msg.center.y));
          }
        } catch (e) { console.warn('init message error', e); }
      } else if (msg.type === 'snap-paint-submit') {
        // çˆ¶çª—å£ç‚¹å‡»â€œç¡®å®šâ€æ—¶å¯¼å‡ºå¹¶è¿”å›
        try {
          let payload;
          if (currentMode === 'bitmap') {
            ensureRasterSize();
            const dataUrl = rasterCanvas.toDataURL('image/png');
            payload = { type: 'snap-paint-result', kind:'bitmap', png: dataUrl, center: { x: rotationCenter.x, y: rotationCenter.y } };
          } else {
            const svgString = exportSnapSVG();
            const layers = exportLayersSVG();
            payload = { type: 'snap-paint-result', kind:'vector', svg: svgString, layers: layers, center: { x: rotationCenter.x, y: rotationCenter.y } };
          }
          window.parent && window.parent.postMessage(payload, '*');
        } catch (e) { console.warn('submit message error', e); }
      }
    });

    // æ¨¡å¼åˆ‡æ¢ï¼ˆçŸ¢é‡ / ä½å›¾ï¼‰
    let currentMode = 'vector';

    // è®©ä½å›¾ç”»å¸ƒä¸ Paper è§†å›¾ä¿æŒåŒå°ºå¯¸ï¼Œå¹¶è€ƒè™‘é«˜ DPI
    function ensureRasterSize(){
      const sz = paper.view.size;
      const w = Math.round(sz.width);
      const h = Math.round(sz.height);
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      // CSS å°ºå¯¸
      rasterCanvas.style.width = w + 'px';
      rasterCanvas.style.height = h + 'px';
      // åƒç´ å°ºå¯¸ï¼ˆä¹˜ä»¥ DPRï¼‰
      const needW = Math.round(w * dpr);
      const needH = Math.round(h * dpr);
      if (rasterCanvas.width !== needW) rasterCanvas.width = needW;
      if (rasterCanvas.height !== needH) rasterCanvas.height = needH;
      // ä½¿ç”¨åæ ‡å˜æ¢ï¼Œç»§ç»­æŒ‰ CSS åƒç´ ç»˜åˆ¶ï¼Œä¿æŒæ¸…æ™°
      const ctx = rasterCanvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
    }

    // å°†å½“å‰çŸ¢é‡å†…å®¹å¿«ç…§åˆ°ä½å›¾ç”»å¸ƒ
    function snapshotVectorToRaster(){
      try {
        const svgString = paper.project.exportSVG({ asString: true });
        const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = function(){
          const ctx = rasterCanvas.getContext('2d');
          ctx.clearRect(0, 0, rasterCanvas.width, rasterCanvas.height);
          // è¦†ç›–ç»˜åˆ¶åˆ°æ•´å¼ ç”»å¸ƒï¼ˆä¸ Paper è§†å›¾åŒå°ºå¯¸ï¼‰
          ctx.drawImage(img, 0, 0, rasterCanvas.width, rasterCanvas.height);
          URL.revokeObjectURL(url);
        };
        img.onerror = function(){ URL.revokeObjectURL(url); };
        img.src = url;
      } catch (e) { /* å¿½ç•¥å¯¼å‡ºå¤±è´¥ */ }
    }

    const rctx = rasterCanvas.getContext('2d');
    // é»˜è®¤éšè—â€œæ—‹è½¬ä¸­å¿ƒâ€æŒ‰é’®
    (function(){ const btn = document.querySelector('#left-tools [data-tool="crosshair"]'); if (btn) btn.style.display = 'none'; })();
    document.getElementById('mode-vector').addEventListener('click', ()=>{
      currentMode = 'vector';
      document.getElementById('mode-vector').classList.add('active');
      document.getElementById('mode-bitmap').classList.remove('active');
      rasterCanvas.style.pointerEvents = 'none';
    });
    document.getElementById('mode-bitmap').addEventListener('click', ()=>{
      currentMode = 'bitmap';
      ensureRasterSize();
      snapshotVectorToRaster();
      document.getElementById('mode-bitmap').classList.add('active');
      document.getElementById('mode-vector').classList.remove('active');
      rasterCanvas.style.pointerEvents = 'auto';
    });

    // ç›‘å¬çª—å£ä¸ Paper è§†å›¾å¤§å°å˜åŒ–ï¼Œä¿æŒä½å›¾ç”»å¸ƒåŒæ­¥
    window.addEventListener('resize', ensureRasterSize, { passive: true });
    paper.view.onResize = function(){ ensureRasterSize(); };

  </script>
</body>
</html>